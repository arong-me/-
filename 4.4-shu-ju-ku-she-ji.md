# 4.4　数据库设计

### 1. 4.4　数据库设计 <a id="4_4&#x3000;&#x6570;&#x636E;&#x5E93;&#x8BBE;&#x8BA1;"></a>

数据建模的目的是设计数据库，数据库设计一般需要考虑三个方面，建立哪些表，这些表之间有什么关联关系，每个表需要哪些字段。

#### 1.1. 4.4.1　表 <a id="4_4_1&#x3000;&#x8868;"></a>

数据库中的表一般对应着现实世界中的实体，或者实体之间的关系，要设计好表需要先处理好实体与实体之间的关系。前面在介绍实体关系时，为了使基本知识容易理解，使用了一些简化的案例，但在实际工作中，对于处理实体关系的考虑远比这些案例复杂，有时候相同的实体之间可能会有不同的关系，有时候实体之间的关系会因业务的发展而变化，有时候会因为引入历史信息导致关系的复杂程度发生本质变化，等等，有时候甚至仅仅确定好实体也不是那么容易的。另外，除了反映实体以及实体关系的数据库表外，在进行数据库设计时，还需要设计许多特殊的表，这些表可能只是为了数据的运算、存储、检索、维护方便而设计，是不能从实体、关系的角度看的。

1.认清实体

一旦明白了什么是实体，我们的第一印象是要确定数据库实体表非常容易，无非就是员工、部门、客户、供应商等，与现实世界中的实体对应就行，但是，数据库设计意义上的实体跟现实世界中的实体还是有本质区别的。

现实世界中的同一实体，在数据库设计时可能会根据业务要求设计多个实体来表达它，因为在不同的业务场景中，需要处理、保存的属性信息区别很大。例如，在现实世界中的“人员”实体，可能会根据业务要求在数据库中设计出“员工”、“销售员”、“采购员”等多个表。也有可能，现实世界中的多个实体，在数据库设计时只设计一个表来表达它，因为虽然这些实体牵涉到不同的业务场景，但需要处理、保存的属性信息区别很小。例如，在现实世界中的“原材料”、“半成品”、“产成品”、“办公用品”等，可能会根据业务要求在数据库中只设计一个“物料”表。具体在数据库设计时，如何确定需要哪些表，是完全使用现实世界的实体，或是将现实世界的实体分拆成多个实体，或是将现实世界的多个实体合并成一个实体，需要根据不同的业务需求确定。

**案例：认清实体**

需要给某公司的IT器材仓库开发管理系统。小王在调研时发现，这个仓库管理该公司所有的计算机配件及网络材料，没有别的物品，因此，决定在数据库中使用“IT配件”表来表达这些物品。

后来，经过进一步的调研，发现本仓库对IT器材的管理会分为两种完全不同的管理方式——可以称为两种不同的管理级别：对于价格较高的重要物品，进行个体级别的管理；对于价格不高的物品，进行规格级别的管理。

所谓个体级别，就是给某种物品的所有个体都编号，对每个个体单独管理，从库存管理的角度，这是最严格的也是管理成本最大的管理方式。例如硬盘，仓库进货时会给每块硬盘都编一个唯一识别号，用标签写好登记，然后贴在硬盘上，这样就意味着可以管理到仓库中每块硬盘的相关信息，如什么时候入库，什么时候出库，存放在什么地方，安装在哪台计算机上等。

所谓规格级别，就是相同名称相同规格的原料都认为是相同的原料，只管理相同规格原料的总数量，不去管理每个个体的具体信息，不去区分进货的批次，例如所有相同的螺丝，只要管理这种螺丝还有多少只或多少千克，不可能给每个螺丝编唯一识别号。

如何为这些物品设计数据库实体呢？小王决定还是使用“IT配件”来表达所有物品，但建立另外一个表“物品个体”，用来登记每个需要管理到个体的物品的相关信息，例如每块硬盘、每块主板的基础信息。在“IT配件”表中，管理物品代号、名称、规格、计量单位等属性；在“物品个体”表中，管理每个个体的编号、入库时间、出库时间、存放位置、安装位置等属性。在这两个实体之间建立一对多的关联关系，当在业务处理过程中需要用到规格级别的物品时，就使用“IT配件”表，当需要用到个体级别的物品时，就同时使用“IT配件”与“物品个体”这两个表。要注意的是，如果仓库不需要管理到物品个体级别，就不需要“物品个体”这个表了，如图4-9所示。

![](http://b.7dtime.com/B01N1216C4/images/00032.jpeg)

图4-9　实体IT配件与物品个体

2.关系是不确定的

即使仅有两种实体，也可能在不同的业务需求中存在不同的关系。例如，实体“学生”与实体“教师”之间，如果只需管理学生所属班级信息，那么也许只有一种关系“分班”，但如果还需要管理教务排课，那么就会多出另外一种关系“选修”。随着信息系统涉及的业务领域越来越多，这种关系也会越来越多。而且这些关系的类别也可能不一样，可能是一对一的关系，可能是一对多的关系，可能是多对多的关系。例如，在“分班”关系中，一个学生只能有一个班主任，一个班主任可以有多个学生，这是一对多的关系，而在“选修”关系中，一个学生可以选多个任课老师的课程，一个任课老师的课程可以被多个学生选修，这是多对多的关系。一句话，实体与实体之间的关系其实并不确定，关键要看需要管理的业务领域，以及每个领域的具体需求。

**案例：表关系是不确定的**

某OA系统，人员与部门的基本业务规则是这样的，一个员工可以在多个部门任职（一个部门为员工的行政隶属部门，其他部门为兼职部门），一个部门可以有多个员工，一个部门只有一个主管，一个员工只能在一个部门担任主管。

分析一下可知，这里部门与人员有三种关系。一是任职关系，由于一个员工可以在多个部门任职，一个部门可以有多个员工，因此，这是多对多的关系。数据库设计的处理方式是建立三个表：“员工”表，用来存放员工基本信息；“部门”表，用来存放部门基本信息；“任职”表，用来表达这种多对多的关系。二是行政隶属关系，在行政上，一个部门可以有多个员工，一个员工只能属于一个部门，因此，这是一对多的关系。数据库设计的处理方式是在“员工”表中加属性“所属行政部门”。三是主管关系，一个部门只允许有一个主管，一个员工只能主管一个部门，因此，这是一对一的关系。数据库设计的处理方式，可以在“部门”表中加属性“主管”，也可以在员工表中加属性“主管部门”，考虑到员工数据的生成要晚于部门数据，优先考虑在员工表中加属性“主管部门”。另外，由于存在任职关系，在“任职”表中加标识字段“是否主管”也是可以考虑的，如图4-10所示。

![](http://b.7dtime.com/B01N1216C4/images/00033.jpeg)

图4-10　实体部门与员工的不确定关系

3.关系是会变化的

企业的业务在发展，管理在变化，实体跟实体之间的关系也在不断变化，原来是一对一的关系，可能会变成一对多的关系，原来一对多的关系可能会变成多对多的关系，反之亦然。软件开发完成后，如果实体的属性发生了变化要处理相对比较容易，但如果实体的关系发生了变化，对软件的影响将是非常剧烈的，有时候甚至可能是致命的。因为实体关系发生了变化，往往意味着需要对数据库中的表结构进行调整，增加表、减少表都有可能，这也就意味着跟这些表相关的所有功能都需要重新编写。有些表，跟它相关的功能少，使用客户不多，也没有过多的历史数据包袱，改动起来还算容易；而有些表，可能有大量的功能跟它相关，又有大量的客户在使用，又包含大量的历史数据，如果要变更，除了重做一套体系几乎没什么更好的选择了。因此，对于数据建模者来说，需要对企业信息化需求在未来的变更或追加有一定的预测能力。

**案例：表关系是会变化的**

小王在某车间进行关于生产任务调度规则的调研，获悉关于调度任务编排的基本方式是，调度员获得生产计划后，根据生产计划的交期要求，以及当前车间中的机器负载情况进行调度任务编排，一个生产计划会被分解成多个调度任务，每个调度任务指明需要加工的产品数量、由哪个班组加工、在哪台机器上加工、要求完成时间等。根据这些规则，小王进行数据模型分析：一个生产计划可以分解多个调度任务，因此生产计划与调度任务的关系是一对多的关系，一个调度任务只能在同一台机器上加工，因此机器与调度任务也是一对多的关系。数据模型如图4-11所示。

![](http://b.7dtime.com/B01N1216C4/images/00034.jpeg)

图4-11　生产计划、机器与调度任务

软件投入使用一段时间后，车间引进了某种新工艺，因为这种新工艺的使用，有的调度任务在车间中被分成了小步骤，不同的小步骤需要在不同的机器上生产，这也就意味着调度任务跟机器的关系由一对多的关系变成了多对多的关系。当小王获得了这种需求变更要求时，感到相当崩溃，因为这意味着以前跟调度任务管理、调度智能运算、工作汇报相关的所有软件功能、查询报表都得进行一次巨大的变更，而且以前的历史数据还需要进行一次痛苦的转换。这可怎么办呢？也许当初在进行数据建模时，就不该使用一对多的方式来处理机器跟调度任务的关系吧，小王一声叹息。处理方式是加一个“机器安排”表，用来存放调度任务与机器的关系信息。新的数据模型如图4-12所示。

![](http://b.7dtime.com/B01N1216C4/images/00035.jpeg)

图4-12　生产计划、机器、调度任务与机器安排

4.历史信息让一对多关系不复存在

有很多系统，或者一个系统中的某些功能，需要保存历史信息，也就是说要保存数据的变动轨迹。例如，某员工开始属于A部门，后来调出了A部门，进入B部门，后来又从B部门调入C部门，由于用户需要记录每个员工在公司的工作轨迹，因此这些信息都需要永久保存。在这种情况下，我们会发现，几乎所有的实体关系都变成了多对多的关系，因为这是个不断变化的世界，信息是对现实世界的反映，用发展与变化的观点看世界，这个世界不存在一对一、一对多的关系，只有多对多的关系，人体器官都可以移植，还有什么关系只停留在一对一、一对多呢？一个学生只属于一个班级？未必，因为学生的班级会变；一个员工只属于一个部门？未必，因为员工的部门会变；一个县只属于一个地级市？未必，因为行政区划会变。当然，在进行数据库设计时未必就需要采用多对多的方式来处理这种关系（如可以采用专门的日志表来存储变更历史），但一定要知道，引入信息历史要求后，会让实体关系变得复杂，在数据建模阶段一定要有所思考。

**案例：历史信息让一对多关系不复存在**

小王在进行某公司人力资源管理系统的数据建模工作，在分析职位与员工的关系后，得出结论，这两个实体是一对多的关系，因为该公司要求，一个员工只能有一个职位，一个职位允许有多个员工。虽然用户没有提出需要保存员工职位变动的历史，但小王根据自己的经验，人力资源管理者总是要分析每个员工的职场发展、职业规划的，到那个时候，分析员工在本公司的职位变动历史将会成为自然而然的需求。考虑到这一点，为了将来系统的可扩展性，小王决定使用多对多的方式来处理“职位”与“员工”这两个实体的关系，即设计三个表，一个“职位”表，一个“员工”表，一个“员工任职”表。

5.一些特殊的表

大部分跟用户业务相关的表都可以通过分析实体及其关系的方式设计，但有时候为了一些特殊的需要，或者为了功能编写方便，或者为了维护方便，或者为了数据管理方便，或者为了性能的要求，会设计一些特殊的表，这些表绝不能仅从实体关系的角度来理解，可以这么说，这些表是为了信息化体系而构建，是为了管理数据本身而建立的表。这里列举一些在工作中经常用到的特殊表，供读者参考。

（1）为了提高大型运算的效率，设计一些数据中转表，这些表仅仅是为了计算过程的方便、高效，跟现实世界中的实体几乎扯不上关系。

（2）为了存储、提取数据的要求，将同一实体或关系的数据分拆成多个表保存，因为降低了被检索数据的数量级而提升了检索效率。

（3）建立结转表，将某时间范围内的历史数据的计算结果保存到结转表，提高数据的统计、汇总效率。

（4）建立历史数据表，将积累下来的很少用到的、占用很多存储空间的、影响数据检索效率的历史数据挪到其中。

（5）在用户使用软件的过程中根据用户的操作动态生成表，这样可以灵活应对用户需求。

（6）将配置参数、开关之类的控制型数据合并到同一张表中，方便维护。

（7）将一些高度相似的基础性实体，合并到一张表，既方便维护、扩展，又可以减少功能开发的工作量。

**案例：一些特殊的表**

好多软件系统都有这样一个表，一般叫“字典表”之类的名字，用来存储各种基础数据，如计量单位、货币单位、学历等。如果从实体的角度来看，这些数据明显都是完全不同的实体，相互之间几乎没有任何关系，但由于这些数据需要管理的信息非常简单且非常相似，无非就是代号、名称之类，因此大家都习惯了将这些数据合并到一张表管理。这样管理起来非常方便，用于维护的增删改查之类的功能也只要写一次，大大减少了开发工作量，以后需要增加数据项时只要配置一个字典就行了，扩展方便。然而，使用这种字典数据也有风险，有时候，可能因为某个基础数据业务属性增多了，就不得不另外增加表，将这个字典剥离开来。令人崩溃的是，这时所有用到这个数据字典的程序都要修改。例如，原来使用了“计量单位”这个字典，只需要代号、名称就可以了，后来因为后期的需求变更，需要增加计量单位的属性，包括这个计量单位是公制还是英制，是什么计量类别（体积、面积、长度、重量等），这时候原来的字典表就无法处理了，不得不另外重新设计一个新表“计量单位”，软件中用到“计量单位”这个字典的所有程序都要修改。当然，为了降低这种风险，可以在字典中加扩展字段，如图4-13所示。

![](http://b.7dtime.com/B01N1216C4/images/00036.jpeg)

图4-13　字典与字典数据

#### 1.2. 4.4.2　表的关系 <a id="4_4_2&#x3000;&#x8868;&#x7684;&#x5173;&#x7CFB;"></a>

首先要说清楚的是，这里谈的“关系”是数据库中表跟表之间的关系，不是实体跟实体之间的关系，表跟表之间的关系包括“一对一”与“一对多”两种，是不存在多对多的关系的，这个跟实体关系不同。现实世界中实体之间的多对多的关系，通常的处理方式是分解成两个一对多的表关系。

1.一对一关系

一对一关系在数据库设计中是很少出现的，如果没有什么特殊情况，这种关系往往都会合并成一个表处理，如果分成两个表处理，那么处理方式类似于一对多的关系。合并成一个表处理，管理方便，数据检索、更新也方便，由于不需要额外关联，可以节约资源开销。然而，也不是所有的情况都适合合并处理的，有时候，由于其中一方的数据很少，会导致浪费存储空间（当然，如今磁盘空间越来越便宜了，这一点倒无须过多考虑）；有时候，由于数据产生的时机并不确定，没有一方可以涵盖另一方的数据记录，合并成一个表未必是个好的想法；有时候，考虑到未来可能发生的关系变化，还是分开两个表容易扩展些。

**案例：表的一对一关系**

小王在某公司进行OA系统需求分析工作。关于人员问题，在数据建模时需要考虑两个不同的概念，一是员工，一是系统用户。员工指在公司工作的所有人员，系统用户指使用本软件系统的人员。前者需要管理入职日期、身份证号、联系方式等信息，后者需要管理登录账号、密码等信息，明显这是两种不同的实体。根据业务需求，不是所有的员工都可以登录本系统的（例如车间生产线上的工人），一个员工只允许有一个登录账号，一个登录账号只允许用于一个员工。小王经过分析后，决定建立两个表，一是“员工”表，一是“用户”表，这两个表的关系是一对一的关系，如图4-14所示。

![](http://b.7dtime.com/B01N1216C4/images/00037.jpeg)

图4-14　员工与用户的一对一关系

在笔者的实际工作中，采用一对一关系的情况基本都发生在围绕某些软件系统（或独立成型的功能模块）做定制化或者补充开发时。被定制的软件系统是相对独立的，很可能是其他公司或团队开发的某种软件产品。由于牵涉到软件功能的修改、维护、升级等一系列工作，不想动、不敢动或者不能动它的数据库——对一个成熟的、正常使用中的软件，没有十足的把握正常人都不愿意修改数据库，因为风险太大。但是，当围绕它做进一步的开发时，可能有些信息在它的数据库中并没有提供表字段，无法处理，怎么办呢？这时候，可以另外建表（是另外建一个数据库，还是直接放在这个系统的数据库中，就要视情况而定了），需要补充的字段就放在这个表中，跟那个需要补充字段的表建立一对一的关系，并使用完全相同的关键字，检索时可以通过一对一的关联获得需要的数据。

**案例：定制产生的一对一关系**

某公司采购了一套CRM软件，用于客户管理、服务支持，已经正式使用三年了。随着业务的发展，管理的提升，公司需要围绕这个软件开发一些补充功能，如客户投诉管理。由于这两年公司引进了一些软件人才，软件团队颇有兵强马壮的感觉，就觉得没必要找原来的软件供应商了，于是决定自己进行定制开发。在数据建模时，考虑到性能的要求，决定在客户基本信息表中增加“最近投诉时间”、“是否存在未处理投诉”等字段。考虑到这个软件系统是别人的产品，如果修改原来的数据库表“客户信息”，直接增加这些字段，很可能在下次对方产品升级时会因为种种原因而丢失其中的信息，于是新增了另外一个表“客户信息2”，与原来的表“客户信息”使用相同的关键字“客户代号”，表中包括“最近投诉时间”、“是否存在未处理投诉”等字段，如果后面再有增加客户信息字段的需求，可以直接在表“客户信息2”中增加字段，不会去变更原来的“客户信息”表，如图4-15所示。

![](http://b.7dtime.com/B01N1216C4/images/00038.jpeg)

图4-15　客户信息的定制

一对一关系包括如下两个小类别。

1 to 0.. 1，对于被依赖的表而言，其中的任意一条记录，在另一个表中的关联记录或者只有一条，或者没有。例如，前面案例中的“客户信息”与“客户信息2”，就是这种关系。

1 to 1，对于被依赖的表而言，其中的任意一条记录，在另一个表中的关联记录有且仅有一条记录。这种情况比较少见，一般都是在后台通过程序产生其中某个表的数据。

**案例：1 to 1**

某软件在建立员工的时候，在“员工”表中插入员工记录的同时在“用户”表中插入一条用户记录，删除员工时同时删除对应的用户，保证一个员工在系统中有且仅有一个用户，这时候，“员工”表与“用户”表就是“1 to 1”这种关系，如图4-16所示。

![](http://b.7dtime.com/B01N1216C4/images/00039.jpeg)

图4-16　员工与用户的“1　to 1”关系

2.一对多关系

数据库中表跟表之间的关系绝大部分都是一对多的关系，在数据库中通过在“多”表中建立外键（Foreign Key）来建立这种关系。例如，数据库中有两个表，一个是“部门”表，一个是“员工”表，一个员工只能属于一个部门，一个部门可以有多个员工，这两个表之间的关系是一对多的关系，处理方式就是在“员工”表中，即“多”的一方，添加外键“所属部门”，当需要的时候可以通过这个外键与“部门”表关联。

一对多的关系也包括如下两个小类别。

1 to 1.. n，对应“一”的一方的一条记录，“多”的一方有一条或多条记录。在实际工作中，这种情况较少。

**案例：1 to 1..n**

某库存管理系统，有两个表，一是“入库单”，一是“入库交易”。需求是当入库时系统生成入库单，一次入库可以收取多种物料入库，但只生成一个入库单，在数据库中，一个入库单对应至少一条入库记录，没有入库记录就不存在入库单。“入库单”管理入库时间、入库人员、供应商等信息；“入库交易”管理入库物料、入库数量等信息。这两个表的关系就是这种“1 to 1..n”的关系，如图4-17所示。

1 to 0.. n，对应“一”的一方的一条记录，“多”的一方可以有一条或多条记录，也可以没有记录。在实际工作中，这种情况占了绝大部分，一些常见的一对多的关系，如部门对员工、班级对学生、客户对订单等，一般都会采用这种关系，虽然没有员工的部门、没有学生的班级、没有订单的客户很少见，但在数据库设计时往往都是允许这些现象存在的。

![](http://b.7dtime.com/B01N1216C4/images/00040.jpeg)

图4-17　入库单与入库交易的“1　to 1..n”关系

3.特殊关系

在实践中，有些特殊的表关系，相信读者在工作中会经常遇到，这里介绍两种特殊关系，一是附属关系，一是递归关系。

1）附属关系

有些表跟表之间的关系是附属性的，即依赖方只能附属于被依赖方才有意义，它们合在一起才是现实意义上的实体。正如人体跟器官的关系：人体跟器官的关系有些类似于机器跟零件的关系，是一对多的关系，一个人体可以有多个器官，一个器官只能属于一个人体，但这里有个特殊的地方——零件可以拆下来用在别的机器上，器官离了人体就没有任何意义，人体跟器官的关系是固定的，不容变更。这种关系本书称之为附属关系。附属关系中，“多”的一方的关键字往往是由多字段组成的，其中有一个或多个字段关联“一”的一方，另外有一个叫作“行号”或“序号”之类的字段。

附属关系在实践中是非常常见的，如果是一对多的关系，在工作中对这种关系有一些俗称，将“一”的一方与“多”的一方分别称为“主表”与“从表”，或者“头表”与“行表”，或者“总表”与“明细表”等。

**案例：表的附属关系**

某软件在保存销售订单时，在数据库中对应三个表，分别叫作“销售订单头”、“销售订单行”与“发货批次”，这三个表依次都是一对多的关系。“销售订单头”中包括下单日期、下单客户、下单人等字段；“销售订单行”中包括物料、数量、价格等字段；“发货批次”中包括交货批次、交货日期、交货数量、交货地点等信息。这三个表就构成了附属关系。离开了“销售订单头”，“销售订单行”没有任何意义，离开了“销售订单行”，“发货批次”也没有任何意义，只有将它们组合在一起，才能表达一个完整的销售订单，如图4-18所示。

![](http://b.7dtime.com/B01N1216C4/images/00041.jpeg)

图4-18　附属关系

2）递归关系

有些表，自己跟自己之间存在一对多的关系，“一”的一方的记录在这个表中，“多”的一方的记录也在这个表中。例如，公司的组织结构，组织结构中的所有节点都是部门，但这些部门之间又有从属关系，某部门的上级是个部门，上级的上级还是部门，以此类推，这样就构成了某种递归关系。

**案例：表的递归关系**

某软件系统的员工表，除了登记该员工的基本信息外，还有字段记录员工直接主管，每个员工只允许有一个直接主管，一个员工可以是多个人的直接主管，充当直接主管的人也是员工。这样，这个表既表达了员工基本信息，还表达了员工的直接主管，从另外一个维度，还表达了员工的直接下属，如图4-19所示。

![](http://b.7dtime.com/B01N1216C4/images/00042.jpeg)

图4-19　递归关系

#### 1.3. 4.4.3　字段 <a id="4_4_3&#x3000;&#x5B57;&#x6BB5;"></a>

在设计数据库时，相对于表及表关系的处理，对字段的处理要简单得多，无非就是根据业务上需要处理的信息决定在表中设计哪些字段，根据信息的内容决定使用什么数据类型，需要的字段长度等。另外，即使字段设计出了问题，对未来工作的影响面也小得多，一般不会像表及表关系出问题那样伤筋动骨。

1.字段来源

表中的字段主要有两大来源，一是表达实体（或实体关系）的属性的字段，一是用于数据管理的管理性字段。

1）属性字段

为了更详细、准确地描述某实体，就需要对它的属性进行精准描述。例如，要精准地描述某一辆车，就需要对这辆车的属性进行描述，如车牌是什么、车主是谁、品牌是什么、型号是什么等，这些属性就构成了数据库表字段的直接来源。不用说，这种字段占了数据库表字段的绝大多数。

属性字段可以分成两大类，一是直接保存属性值的字段，如直接存储的员工姓名、身份证号码、邮政编码之类；一是用于保存对另外一个表的引用的字段，如“员工”表的属性“所属部门”，可能另外有一个表描述每个部门，在“员工”表中只是设置了一个关联字段（外键），用于表达员工在哪个部门，至于那个部门的具体属性，会在对方表中进行详细的描述。

2）管理性字段

在设计数据库时，许多团队往往会设计一些字段用于数据的管理，如创建信息、更新信息等。一般设计这些字段属于团队规范的范畴，对于需求人员来说，考虑的重点在业务信息相关的字段上，可以不去考虑这些管理字段。当然，如果团队没有这种规范，需求人员就需要自己策划是不是需要这方面的数据管理信息。一些常见的管理性字段如下。

创建信息：记录每条记录的来源，一般包括记录创建人、创建时间、创建IP、创建功能点等字段。

更新信息：记录每条记录的最近更新来源，一般包括更新人、更新时间、更新IP、更新功能点等字段。记录更新信息最大的作用是，一旦发生了某些异常情况，可以进行追踪，如果没有保存操作日志，这种信息几乎就成了追踪异常情况的唯一线索了。

数据区划标志：有的时候，为了在同一个数据库中人为分隔开某些数据，可以通过这种标志区分出。一般情况下，属于某特定分区中的用户，只能浏览、操作自己所属分区中的数据，不能浏览操作其他分区中的数据，但有的时候，又需要对这些分区中的数据进行联合分析、处理。常见的如账套、分公司之类的标志。

逻辑删除标志：逻辑删除，又称为“假删除”，可以在数据表中建立一个“逻辑删除标志”字段，用户删除数据时就更新这个字段，打上标志，当用户浏览数据时，将打了删除标志的记录排除在外，对系统而言，数据还在，对用户而言，数据已删除。

2.主键

所有的表都必须要有一个主键，这一点不容违反。主键一般可以分为两种类型，一是用单字段作主键，如“员工”表中用字段“员工工号”作主键；一是用多字段作主键，如“员工任职”表中，用字段“员工工号”与“岗位代号”合并在一起作主键。物理设计时，一般有两种方式处理主键，一是用属性字段作主键，如前面所说的“员工”表，用“员工代号”作主键；还有一种方式是建立某种流水号或序列号（常见的方式有数据库自动生成INT序列，或者生成GUID全球唯一标识号），然后用这个号作主键，这种方式的优势是可以降低开销、提高性能，缺点是主属性不明确，容易掩盖设计问题，用这种方式设计主键的数据库，需要通过数据库或者业务逻辑，控制某些字段不能重复、不能修改等，否则很容易造成数据混乱。

关键字设计需要当心，因为它很可能会被别的表（建立了与之关联的外键的表）引用，一旦正式使用，产生了历史数据后，再想更改将是非常麻烦，甚至不可能的事。

**案例：错误的主键**

某软件的“部门”表，为了在界面上生成公司组织的树状结构，系统会给每个部门自动编一个码，大概是这种形式：“011”，“011020”，“011020007”。其中，前几位代表它的上级部门，后三位为本部门的代码。设计时，想想这个编码是全局唯一的，就顺便用来作关键字了。软件投入使用后，用户提出需要调整某些部门的所属部门，由于这个用于作关键字的编码表达了部门的从属关系，如果某部门的上级部门更换了，那么意味着，需要变更这个部门的关键字，同时这个部门的所有下属部门的关键字都要随之修改。可是，许多表都引用了这个部门，如“员工”的“所属部门”，系统中已经存在了大量的历史数据，事情貌似没法收拾了。

3.数据类型

现实世界中的数据类型一般包括文本、数值、时间、文件、图片、音频、视频等，通常的处理方式是在数据库中保存文本、数值、时间这些信息，而图片、视频之类的数据往往会另外建立文件管理系统处理，然后在数据库记录中存储文件路径。当然，将这类数据直接保存在数据库中也未必不可以，但大部分情况下这都不是一个好想法，因为存储、读取这种类型的数据并不是数据库的长项。在数据库层面，为了性能、存储空间等方面的考虑，还会对这些数据进行进一步细化，如数值类的数据，可以分成整型、长整型、小数等，不同的数据库管理系统（DBMS）有不同的处理方式。例如，MySQL的数值类型包括TINYINT、SMALLINT、MEDIUMINT、INT、INTEGER、BIGINT、FLOAT、DOUBLE等十多种类型。在确定字段的数据类型时，要根据实际需要确定，既要保证有足够的存储空间，又要考虑处理性能，既要保证未来的扩展，又不能浪费太多空间。

**案例：数据类型**

小王在某公司进行员工信息管理系统的需求调研，现在需要对每个员工进行编号，如何决定“员工编号”字段的类型呢？由于员工编号被引用的地方很多，又需要以固定格式打印在许多单据上，小王决定使用定长字符串型——对应数据库中的CHAR（X）——来处理这个字段。需要的长度是多少呢？小王分析，该公司目前有七百多名员工，业务需求中的员工编号规则为以公司的三个字母缩写开头，后面跟三位的流水号，如“TCC125”之类的。考虑到该公司每年大概有10%的离职率，而员工编号是不能重用的，如果维持现在这种规模与状态，在三四年之后，需要的员工编号就会突破1000个，可以想象，流水号至少要扩充到4位。另外，为了应对潜在的扩展要求（万一这几年公司有了井喷式的发展），将流水号留到5位是比较靠谱的想法。因此，字段“员工编号”的最终长度被设成了8位，员工编号采用“TCC00125”这种格式。

在实际工作中，当需要确定定长字段的长度时，笔者的习惯是，考虑按当前这种业务规模，本系统被正常使用5年之后产生的大概数据总量，然后再放宽1位。

4.默认值

为了数据处理的方便与降低性能开销，建议所有的字段都要有默认值，如果没有特殊的需要，一般数值型的字段可以默认为“0”，文本型的字段可以默认为"。有了默认值后，数据库方面不需要处理NULL，减少了开销，在应用程序开发方面，不需要做字段值是否是NULL的判断，减少了开发的麻烦。

#### 1.4. 4.4.4　数据字典 <a id="4_4_4&#x3000;&#x6570;&#x636E;&#x5B57;&#x5178;"></a>

数据建模完成后，需要有文档对建成的数据模型进行详细说明，这就是数据字典应该完成的任务。数据字典分为两种层级，一是面向数据库逻辑设计的数据字典，一是面向数据库物理设计的数据字典，前者从业务需求层面描述数据模型，后者从具体的数据库管理系统（DBMS）的层面描述数据库结构。本书所说的数据字典是针对逻辑设计的。

数据字典需要描述的内容主要包括：数据模型中有哪些表，每个表包括哪些字段，每个字段的类型、长度、取值范围是什么，哪些字段是外键关联字段，对字段值有没有什么特殊要求，等等。

不同的团队，可以有不同的数据字典编写、管理方式，有直接在建模工具中管理的，有用Access管理的，有用Excel管理的，有用Word管理的，还有忽略数据字典直接查看数据库的。各种方式，各有优缺点，说不清楚哪种最好，哪种最不好，关键是适合自己的才是最好的。

这里提供一种数据字典模板，供读者在工作中参考，见表4-11。

![](http://b.7dtime.com/B01N1216C4/images/00043.jpeg)

说明：

表名：对应数据模型中的表，每个表都要在数据字典中建立一个与之对应的档案。有些团队，提供通用性的，或者说平台化的表，如用户、角色之类，由于这些表是属于团队的通用规范，应该另外有文档说明，就不需要在这里列出了。

字段：罗列所有的业务字段，有些用于数据管理的字段，如逻辑删除标志、更新时间之类的字段，如果团队有这方面的规范，可以不在这里列出。另外，这里只需要从用户的视角写出字段名称，不需要进行规范的面向数据库的字段命名、编号，那是物理设计需要完成的工作。

数据类型：从用户的视角描述这个字段的数据类型，如文本、数值、时间、图片等，这里并不要求精确到数据库中具体的数据类型（如Double、Int等）——这是物理设计需要完成的工作。

范围：如果是文本型，需要写明这个字段的长度，如“200字符”；如果是数值型，需要写明这个字段的取值范围，如“1～100的正整数”。

数据来源：如果该字段来自于某字典，则在这里写上字典的编号，严格说来，这也是一种外键；如果该字段只提供固定选项，用户不能自己配置，则用大括号与竖线表示，如字段“员工状态”，假设系统中只允许有三种状态，分别是“试用”、“在职”、“离职”，那么数据来源可以写成“｛试用｜在职｜离职｝”。在这种情况下，一般允许在功能逻辑代码中写死，如可以出现“If Staff.Status='试用'”之类的语句。

特殊要求：对数据的特殊要求，如字段“客户代号”，假设需要以地区缩写的两个字母开头，后跟4位流水号，那么可以在这里写上这种格式要求。

外键：如果该字段属于外键关联字段，那么在这里写出外键关联的表名，如“员工”表的字段“所属部门”，可以在这里写上“部门表”。注意，这里只需要写上表名，不需要写上具体字段，因为关联的一定是对方的关键字。这项也可以归入“数据来源”，不过因为它的重要性，建议单列一项。

必填项：如果在新增、编辑时，该字段不允许为空，则在这里写“Y”。

默认值：如果有特殊的默认值，就在这里写上。如果不写，表示没有默认值，或表示按某种团队规范、项目规范生成默认值，如数值型默认“0”，文本型默认"，时间型默认“1900-01-01 00：00：00”等，这种规则不同的团队自然可以有不同的处理方式。

案例：数据事例，要求要符合逻辑，有助于读者理解。

备注：一些补充说明，注意事项等。

**案例：数据字典**

某软件系统数据字典节选，见表4-12。  


